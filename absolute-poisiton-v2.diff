diff --git a/include/kari/util/misc.h b/include/kari/util/misc.h
index 3fcb45c..ddb9c2c 100644
--- a/include/kari/util/misc.h
+++ b/include/kari/util/misc.h
@@ -63,3 +63,91 @@ namespace macro {
   void wait(int ms);
   void print(const char * text);
 }
+
+#ifndef PI
+const float PI = 3.1415;
+#endif
+
+inline int sign(int num)
+{
+	if (num < 0)
+		return -1;
+	return 1;
+}
+inline float sqr(float x)
+{
+	return x * x;
+}
+inline float toRad(float deg)
+{
+	//PI/180 = 0.017453
+	return (deg * 0.017453);
+}
+inline float toDeg(float rad)
+{
+	return (rad / 0.017453);
+}
+inline float avg(float a, float b)
+{
+	return ((a + b) / 2.0);
+}
+inline float limUpTo(float max, float x)
+{
+	if (abs(x) < max)
+		return x;
+	else
+		return sign(x) * max;
+}
+inline float limDownTo(float min, float x)
+{
+	if (abs(x) > min)
+		return x;
+	else
+		return sign(x) * min;
+}
+inline float clamp(float max, float min, float amnt)
+{
+	if (amnt > max)
+		return max;
+	if (amnt < min)
+		return min;
+	return amnt;
+}
+inline float normAngle(float degrees)
+{
+	if (degrees > 180)
+		return (degrees - 360);
+	else if (degrees < -180)
+		return (degrees + 360);
+	return degrees;
+}
+inline float boundAngle(float radians)
+{ //keeps radians within -PI to +PI
+	while (radians < -PI)
+		radians += 2 * PI;
+	while (radians >= PI)
+		radians -= 2 * PI;
+	return radians;
+}
+inline float encoderDistInch(int rawSensor)
+{
+	const float wheelDiam = 2.75;
+	const int countsPerRev = 360;
+	const int gearRatio = 1; //1 to 1
+	return (rawSensor * PI * wheelDiam) / (countsPerRev * gearRatio);
+}
+inline float encoderDistInchBASE(int rawSensor)
+{
+	const float wheelDiam = 4.140; //base wheels
+	const int countsPerRev = 360;
+	const int gearRatio = 1; //1 to 1
+	return (rawSensor * PI * wheelDiam) / (countsPerRev * gearRatio);
+}
+inline bool isWithinBounds(const float current, const float goal, const float thresh)
+{
+	return (fabs(current - goal) < thresh);
+}
+inline bool isWithinAngleBounds(const float current, const float goal, const float thresh)
+{
+	return (fabs(normAngle(current - goal)) < thresh);
+}
\ No newline at end of file
diff --git a/include/kari/util/odometry.h b/include/kari/util/odometry.h
index d9123ec..ae2c9b1 100644
--- a/include/kari/util/odometry.h
+++ b/include/kari/util/odometry.h
@@ -3,6 +3,17 @@
 
 extern pros::ADIEncoder LEncoder, REncoder, MEncoder;
 
+class Position
+{
+public:
+  Position() : X(0), Y(0), heading(0) {}
+  Position(double x, double y, double angle) : X(x), Y(y), heading(angle) {}
+  double X = 0, Y = 0, heading = 0;
+  double distanceToPoint(Position p1)
+  {
+    return sqrt(sqr(p1.X - X) + sqr(p1.Y - Y));
+  }
+};
 class Odom {
   public:
 
@@ -24,6 +35,11 @@ class Odom {
     double * getX();
     double * getY();
 
+    // tracking wheel version
+    double * getPosX();
+    double * getPosY();
+    double * getPosHeading();
+
     Odom& calibrateGyro();
     Odom& zero();
     Odom& reset();
@@ -42,4 +58,8 @@ class Odom {
     static double thetaRad, thetaDeg, offset, posX, posY;
 
     static double output, DesiredX, DesiredY, Desiredtheta;
+
+    static double wheelWidth;
+
+    static Position pos, t_pos;
 };
diff --git a/src/initialize.cpp b/src/initialize.cpp
index 8d4eac0..66866be 100644
--- a/src/initialize.cpp
+++ b/src/initialize.cpp
@@ -20,7 +20,16 @@ void initialize() {
 
   // Class Initialization
   Odom odom;
-  Chassis chassis(odom.getL(), odom.getR(), odom.getM(), odom.getThetaDeg(), odom.getX(), odom.getY());
+
+  //tracking wheel version. using IMU angle
+  Chassis chassis(odom.getL(), odom.getR(), odom.getM(), odom.getThetaDeg(), odom.getPosX(), odom.getPosY());
+  
+  //tracking wheel version
+  //Chassis chassis(odom.getL(), odom.getR(), odom.getM(), odom.getPosHeading(), odom.getPosX(), odom.getPosY());
+  
+  //IMU version
+  //Chassis chassis(odom.getL(), odom.getR(), odom.getM(), odom.getThetaDeg(), odom.getX(), odom.getY());
+
   // Rack rack;
   // Arm arm;
   Display Disp;
@@ -58,13 +67,16 @@ void initialize() {
       .addInfo("Middle", 'i', odom.getM())
       .addInfo("Deg Theta", 'd', odom.getThetaDeg())
       .addInfo("Rad Theta", 'd', odom.getThetaRad())
-      .addInfo("x1-LF", 'd', odom.getLF())
-      .addInfo("y1-RF", 'd', odom.getRF())
-      .addInfo("y2-LB", 'd', odom.getLB())
-      .addInfo("x2-RB", 'd', odom.getRB());
+      .addInfo("X", 'd', odom.getX())
+      .addInfo("Y", 'd', odom.getY())
+      .addInfo("Pos Heading", 'd', odom.getPosHeading())
+      .addInfo("Pos X", 'd', odom.getPosX())
+      .addInfo("Pos Y", 'd', odom.getPosY())
+      .addInfo("X1 LF", 'd', odom.getLF())
+      .addInfo("Y1 RF", 'd', odom.getRF())
+      .addInfo("Y2 LB", 'd', odom.getLB())
+      .addInfo("X2 RB", 'd', odom.getRB());
 
-      // .addInfo("X", 'd', odom.getX())
-      // .addInfo("Y", 'd', odom.getY())
 
   // Disp.addInfo("Rack", 'i', rack.getPot())
   //     .addInfo("Arm", 'd', arm.getPos())
diff --git a/src/kari/control/chassis.cpp b/src/kari/control/chassis.cpp
index e2561b0..1ae8098 100644
--- a/src/kari/control/chassis.cpp
+++ b/src/kari/control/chassis.cpp
@@ -258,7 +258,6 @@ Chassis& Chassis::smartstrafe(double direction_, double theta_, double drivespee
   return *this;
 }
 
-// Use middle trakcing wheel to acheive smart strafe
 Chassis& Chassis::strafe(double x, double y, int speed_, double rate_) {
   currTarget = 0;
   if(target.size() != 1) target.resize(1);
@@ -735,11 +734,11 @@ void Chassis::run() {
 
       case STRAFING_XDRIVE: {
         double x, y;
-        # if 0 // using tracking wheel
-        Vector2 v0 = {(double)(*odomL + *odomR ) / 2, (double)*odomM};
+        # if 1 // using absolute position
+        Vector2 v0 = {*posX, *posY};
         Vector2 v = xdriveXform(v0);
         x, y = v.x, v.y;
-        #else // using ADI
+        #else // using motor
         x = (LF.get_position() - RB.get_position()) / 2 ;
         y = (LB.get_position() - RF.get_position()) / 2;
         #endif
diff --git a/src/kari/util/odometry.cpp b/src/kari/util/odometry.cpp
index e4426db..4874cc4 100644
--- a/src/kari/util/odometry.cpp
+++ b/src/kari/util/odometry.cpp
@@ -6,7 +6,7 @@
 
 pros::ADIEncoder LEncoder(1, 2, true),
                  REncoder(7, 8, true),
-                 MEncoder(3, 4);
+                 MEncoder(3, 4, true);
 
 pros::Imu Imu_L(20), Imu_R(3);
 
@@ -21,6 +21,11 @@ double Odom::thetaRad = 0, Odom::thetaDeg = 0, Odom::offset = 0, Odom::posX = 0,
 
 double Odom::output = 0, Odom::Desiredtheta = 0, Odom::DesiredX = 0, Odom::DesiredY = 0;
 
+double Odom::wheelWidth = 14.75; //in inch
+
+Position Odom::pos = Position(0,0,0);
+Position Odom::t_pos = Position(0,0,0);
+
 double * Odom::getLF() {
   return &currentLF;
 }
@@ -77,6 +82,18 @@ double * Odom::getY() {
   return &posY;
 }
 
+double * Odom::getPosX() {
+  return &pos.X;
+}
+
+double * Odom::getPosY() {
+  return &pos.Y;
+}
+
+double * Odom::getPosHeading() {
+  return &pos.heading;
+}
+
 Odom& Odom::calibrateGyro() {
   // Imu_T.reset();
   Imu_L.reset();
@@ -100,6 +117,8 @@ Odom& Odom::zero() {
 
 Odom& Odom::reset() {
   posX = posY = 0;
+  pos.X = pos.Y = 0;
+  t_pos.X = t_pos.Y = 0;
   return *this;
 }
 
@@ -120,36 +139,53 @@ void Odom::run() {
   isRunning = true;
 
   while(isRunning) {
-    inertL = abs( Imu_L.get_heading() - 360 ) * PI / 180;
-    inertR = abs( Imu_R.get_heading() - 360 ) * PI / 180;
-
-    float x = ( cos( inertL - offset + PI ) + cos( inertR - offset + PI ) ) / 2;
-    float y = ( sin( inertL - offset + PI ) + sin( inertR - offset + PI ) ) / 2;
-
-    thetaRad = abs( atan2f(y, x) + PI );
-    thetaDeg = thetaRad * 180 / PI;
-
+    // Get dx=(deltaL+deltaR)/2 and dy=deltaM
     currentL = LEncoder.get_value();
     currentR = REncoder.get_value();
     currentM = MEncoder.get_value();
-
-    deltaL = currentL - lastDeltaL;
+    deltaL = currentL- lastDeltaL;
     deltaR = currentR - lastDeltaR;
     deltaM = currentM - lastDeltaM;
+    lastDeltaL += deltaL;
+    lastDeltaR += deltaR;
+    lastDeltaM += deltaM;
 
+    // Use IMU to calculate position
+    inertL = abs( Imu_L.get_heading() - 360 ) * PI / 180;
+    inertR = abs( Imu_R.get_heading() - 360 ) * PI / 180;
+    float x = ( cos( inertL - offset + PI ) + cos( inertR - offset + PI ) ) / 2;
+    float y = ( sin( inertL - offset + PI ) + sin( inertR - offset + PI ) ) / 2;
+    thetaRad = abs( atan2f(y, x) + PI );
+    thetaDeg = thetaRad * 180 / PI;
+    // Calculate absolute position
     posX = posX + (( deltaL + deltaR ) / 2) * cos( thetaRad );
     posY = posY + (( deltaL + deltaR ) / 2) * sin( thetaRad );
 
-    lastDeltaL = LEncoder.get_value();
-    lastDeltaR = REncoder.get_value();
-    lastDeltaM = MEncoder.get_value();
-
+    // Use tracking wheels to calculate position
+    float dL = encoderDistInch(deltaL);
+    float dR = encoderDistInch(deltaR);
+    float dy = encoderDistInch(deltaM);
+    float dx = avg(dR, dL);                                  
+    float dHeading = toDeg(dR - dL) / Odom::wheelWidth;
+    float avgHeading = normAngle(pos.heading + dHeading / 2.0);
+    float radHeading = boundAngle(toRad(avgHeading));
+    // Update current r position.
+    t_pos.heading = (t_pos.heading - dHeading); //should this be normalized???
+    t_pos.X += dx * cos(radHeading) + dy * sin(radHeading);
+    t_pos.Y += dx * sin(radHeading) - dy * cos(radHeading);
+    //add little vector after calculating H mech's position
+    const float distToCenter = (wheelWidth / 2); //inches the center of the H mech to the center of r's rotation
+    pos.heading = normAngle(t_pos.heading + 90);
+    pos.X = t_pos.X; // + distToCenter * cos(radHeading);
+    pos.Y = t_pos.Y; // + distToCenter * sin(radHeading) - distToCenter;
+
+    // read motor poistions
     currentLB = LB_get_position();
     currentLF = LF_get_position();
     currentRB = RB_get_position();
     currentRF = RF_get_position();
 
-    pros::delay(10);
+    pros::delay(2); //TODO
   }
 }
 
